using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace ShadowrunGM.SourceGen;

[Generator]
public class CqrsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        //if (!System.Diagnostics.Debugger.IsAttached)
        //{
        //    System.Diagnostics.Debugger.Launch();
        //}
#endif

        IncrementalValuesProvider<INamedTypeSymbol> baseTypedSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is BaseTypeDeclarationSyntax { BaseList.Types.Count: > 0 },
                transform: static (context, _) => GetSemanticTargetForGeneration(context))
            .Where(static m => m is not null)!;

        context.RegisterSourceOutput(baseTypedSymbols.Collect(),
            static (context, namedTypedSymbols) => Execute(context, namedTypedSymbols));
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> namedTypedSymbols)
    {
        if (namedTypedSymbols.Length > 0)
        {
            IGrouping<string, INamedTypeSymbol>[] groupedByNamespace = [.. namedTypedSymbols.GroupBy(x => x.ContainingNamespace?.ToDisplayString() ?? "Global")];

            foreach (IGrouping<string, INamedTypeSymbol> namespaceGroup in groupedByNamespace)
            {
                ImmutableArray<INamedTypeSymbol> symbolsInNamespace = [.. namespaceGroup];
                string namespaceName = namespaceGroup.Key;
                string className = $"{namespaceName.Split('.').Last()}HttpClient";
                string httpClientCode = GenerateHttpClientCode(namespaceName, className, symbolsInNamespace);
                context.AddSource($"{className}.g.cs", SourceText.From(httpClientCode, Encoding.UTF8));

            }

            foreach (INamedTypeSymbol namedTypedSymbol in namedTypedSymbols)
            {
                string cqrsCode = GenerateCqrsCode(namedTypedSymbol);
                context.AddSource($"{namedTypedSymbol.Name}_Generated.g.cs", SourceText.From(cqrsCode, Encoding.UTF8));
            }

        }

        string httpClientRegistrationCode = GenerateHttpClientRegistrationCode(namedTypedSymbols);
        context.AddSource("HttpClientRegistration.g.cs", SourceText.From(httpClientRegistrationCode, Encoding.UTF8));
    }

    private static string GenerateHttpClientRegistrationCode(ImmutableArray<INamedTypeSymbol> namedTypeSymbols)
    {
        IGrouping<string, INamedTypeSymbol>[] groupedByNamespace = [.. namedTypeSymbols.GroupBy(x => x.ContainingNamespace?.ToDisplayString() ?? "Global")];

        StringBuilder sourceBuilder = new($@"// <auto-generated />
#nullable enable
using Microsoft.Extensions.DependencyInjection;
");

        foreach (IGrouping<string, INamedTypeSymbol> namespaceGroup in groupedByNamespace)
        {
            sourceBuilder.AppendLine($@"using {namespaceGroup.Key};");
        }

        sourceBuilder.Append($@"

namespace ShadowrunGM.ApiSdk;

public static class HttpClientRegistrationExtensions
{{
    public static IServiceCollection RegisterHttpClients(this IServiceCollection services, ShadowrunGmApiOptions options)
    {{
");

        foreach (IGrouping<string, INamedTypeSymbol> namespaceGroup in groupedByNamespace)
        {
            sourceBuilder.AppendLine($@"        services.AddHttpClient<{namespaceGroup.Key.Split('.').Last()}HttpClient>(client => client.BaseAddress = options.BaseAddress);");
        }

        sourceBuilder.Append($@"        return services;
    }}
}}");

        return sourceBuilder.ToString();
    }

    private static string GenerateHttpClientCode(string namespaceName, string className, ImmutableArray<INamedTypeSymbol> symbolsInNamespace)
    {
        StringBuilder sourceBuilder = new($@"// <auto-generated />
#nullable enable
using ShadowrunGM.ApiSdk.Common;
using ShadowrunGM.ApiSdk.Common.Results;
using System.Net.Http.Headers;
using System.Net.Mime;
using System.Text.Json;

namespace {namespaceName};

public sealed class {className}(HttpClient httpClient, JsonSerializerOptions options)
{{
    private readonly HttpClient _httpClient = httpClient;
    private readonly JsonSerializerOptions _options = options;
");

        foreach (INamedTypeSymbol namedTypeSymbol in symbolsInNamespace)
        {
            AddGenerateHttpClientCqrsMethodCode(sourceBuilder, namedTypeSymbol);
        }

        sourceBuilder.Append($@"
    private async Task<HttpResponseMessage> PostAsync(IRequest request, MemoryStream memoryStream, CancellationToken cancellationToken)
    {{
        memoryStream.Seek(0, SeekOrigin.Begin);

        using HttpRequestMessage requestMessage = new(HttpMethod.Post, request.GetApiEndpoint());
        using StreamContent requestContent = new(memoryStream);

        requestMessage.Content = requestContent;
        requestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(MediaTypeNames.Application.Json));
        requestContent.Headers.ContentType = new MediaTypeHeaderValue(MediaTypeNames.Application.Json);

        return await _httpClient.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead, cancellationToken)
            .ConfigureAwait(false);
    }}
}}");

        return sourceBuilder.ToString();
    }

    private static void AddGenerateHttpClientCqrsMethodCode(StringBuilder sourceBuilder, INamedTypeSymbol namedTypeSymbol)
    {
        string methodName = GenerateCqrsMethodName(namedTypeSymbol);
        string returnType = string.Empty;
        bool isGeneric = false;
        bool isCommand = false;

        foreach (INamedTypeSymbol iface in namedTypeSymbol.AllInterfaces)
        {
            if (iface.Name is "ICommand" or "IQuery")
            {
                isCommand = iface.Name is "ICommand";

                if (iface.IsGenericType && iface.TypeArguments.Length > 0)
                {
                    isGeneric = true;
                    returnType = iface.TypeArguments[0]
                        .ToDisplayString()
                        .Replace("?", string.Empty);
                }
                break;
            }
        }

        string variableName = isCommand ? "command" : "query";

        sourceBuilder.Append(@$"
    public async Task<Result{(isGeneric ? $"<{returnType}>" : string.Empty)}> {methodName}Async({namedTypeSymbol.ToDisplayString()} {variableName}, CancellationToken cancellationToken = default)
    {{
  ");
        if (isCommand)
        {
            sourceBuilder.Append(@$"
        using MemoryStream memoryStream = new();
 
        await JsonSerializer.SerializeAsync(memoryStream, {variableName}, _options, cancellationToken)
            .ConfigureAwait(false);
        
        using HttpResponseMessage responseMessage = await PostAsync({variableName}, memoryStream, cancellationToken)
            .ConfigureAwait(false);

        return await responseMessage.ToResult{(isGeneric ? $"FromJsonAsync<{returnType}?>" : "Async")}({(isGeneric ? "_options, " : string.Empty)}cancellationToken: cancellationToken)
            .ConfigureAwait(false);
    }}

");
        }
        else
        {
            sourceBuilder.Append(@$"
        using HttpResponseMessage responseMessage = await _httpClient.GetAsync(new Uri(_httpClient.BaseAddress!, query.GetApiEndpoint()), HttpCompletionOption.ResponseHeadersRead, cancellationToken)
            .ConfigureAwait(false);

        return await responseMessage.ToResultFromJsonAsync<{returnType}?>(_options, cancellationToken)
            .ConfigureAwait(false);
    }}

");
        }
    }

    private static string GenerateCqrsCode(INamedTypeSymbol namedTypedSymbol)
    {
        bool isGeneric = false;
        string namespaceName = namedTypedSymbol.ContainingNamespace.ToDisplayString();
        string baseTypeName = GenerateCqrsMethodName(namedTypedSymbol);
        string baseType = namedTypedSymbol.IsReadOnly ? "record" : "class";
        string clientName = $"{namespaceName.Split('.').Last()}HttpClient";
        string returnType = string.Empty;
        string sealedModifier = namedTypedSymbol.IsSealed ? "sealed " : string.Empty;
        string accessibilityModifier = namedTypedSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            _ => throw new NotSupportedException($"Unsupported accessibility: {namedTypedSymbol.DeclaredAccessibility}")
        };


        foreach (INamedTypeSymbol iface in namedTypedSymbol.AllInterfaces)
        {
            if (iface.Name is "ICommand" or "IQuery")
            {
                if (iface.IsGenericType && iface.TypeArguments.Length > 0)
                {
                    isGeneric = true;
                    returnType = iface.TypeArguments[0]
                        .ToDisplayString()
                        .Replace("?", string.Empty);
                }
                break;
            }
        }

        string command = $@"// <auto-generated />
{(isGeneric ? "#nullable enable" : string.Empty)}
using ShadowrunGM.ApiSdk.Common;
using ShadowrunGM.ApiSdk.Common.Results;

namespace {namespaceName};

{accessibilityModifier} {sealedModifier}partial {baseType} {namedTypedSymbol.Name}
{{
    public async Task<Result{(isGeneric ? $"<{returnType}>" : string.Empty)}> ExecuteAsync(CancellationToken cancellationToken = default)
    {{
        {clientName} client = Config.ServiceResolver.GetRequiredService<{clientName}>();
        return await client.{baseTypeName}Async(this, cancellationToken);
    }}
}}";

        return command;
    }

    private static string GenerateCqrsMethodName(INamedTypeSymbol namedTypedSymbol) =>
        namedTypedSymbol.Name
            .Replace("Command", string.Empty)
            .Replace("Query", string.Empty)
            .Replace("Async", string.Empty);

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        BaseTypeDeclarationSyntax baseTypeDeclarationSyntax = (BaseTypeDeclarationSyntax)context.Node;
        SemanticModel semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(baseTypeDeclarationSyntax) is not INamedTypeSymbol baseTypeSymbol || baseTypeSymbol.IsAbstract)
        {
            return null;
        }

        bool implementsInterface = baseTypeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString() is "ShadowrunGM.ApiSdk.Common.IRequest");

        return implementsInterface ? baseTypeSymbol : null;
    }
}

# ShadowrunGM Project Tech Stack Analysis

*Generated by Claude Code analysis on August 29, 2025*

## Executive Summary

ShadowrunGM is a well-architected .NET 9 solution implementing a modern tabletop RPG assistant with sophisticated document processing capabilities. The architecture demonstrates Domain-Driven Design principles with a custom CQRS implementation, advanced PostgreSQL features, and a mobile-first Blazor WebAssembly frontend.

---

## Current Architecture Overview

### Solution Structure
The solution follows a clean, layered architecture with clear separation of concerns:

```
ShadowrunGM/
├── src/
│   ├── API/              # ASP.NET Core backend
│   ├── UI/               # Blazor WebAssembly frontend  
│   ├── ApiSdk/           # Shared client SDK
│   └── SourceGen/        # Source generators for CQRS
└── docs/                 # Comprehensive documentation
```

**Key Architectural Characteristics:**
- **Domain-Driven Design**: Clear domain boundaries and entities
- **Clean Architecture**: Dependencies flow inward, no circular references  
- **CQRS Pattern**: Custom implementation without MediatR overhead
- **Source Generation**: Compile-time HTTP client generation
- **Result Pattern**: Robust error handling throughout the stack

---

## Frontend: Blazor WASM + MudBlazor Implementation

### Technology Stack
- **Blazor WebAssembly 9.0**: Client-side C# execution
- **MudBlazor 8.11.0**: Material Design component library
- **Progressive Web App**: Service worker, offline capabilities
- **MudBlazor.Markdown**: Rich text rendering for GM responses

### Architecture Patterns

#### Responsive Design Implementation
The UI demonstrates sophisticated responsive patterns:

**Desktop (MdAndUp):**
- Mini drawer navigation with expandable states
- Persistent right-rail chat panel
- Tooltip-enhanced collapsed navigation

**Mobile (SmAndDown):**
- App bar with hamburger menu
- Temporary bottom drawer for chat
- Fullscreen chat toggle capability

#### Component Architecture (`MainLayout.razor:1-213`)
```csharp
// Desktop drawer with mini/expanded states
<MudDrawer Variant="DrawerVariant.Mini" @bind-Open="_leftOpenDesktop">
    
// Mobile temporary drawer
<MudDrawer Variant="DrawerVariant.Temporary" @bind-Open="@_leftOpenMobile">
```

#### State Management
- Local component state management
- JavaScript interop for theme persistence (`src/UI/wwwroot/theme.js`)
- Chat state with mock GM responses (`Components/ChatPanel.razor:104`)

### PWA Implementation
Full Progressive Web App capabilities:
- Service worker registration (`ServiceWorkerAssetsManifest`)
- Manifest files for light/dark themes
- Offline-first chat interface design

---

## Backend: ASP.NET Core with Custom CQRS

### Technology Stack
- **ASP.NET Core 9.0**: High-performance web API
- **PostgreSQL with pgvector**: Vector database for embeddings
- **Entity Framework Core 9.0**: ORM with advanced PostgreSQL features
- **Semantic Kernel 1.63.0**: AI integration framework
- **Ollama Integration**: Local LLM embedding generation

### CQRS Implementation Without MediatR

#### Custom Source-Generated CQRS (`src/SourceGen/CqrsGenerator.cs`)
The project implements a sophisticated source generator that:

1. **Detects CQRS Interfaces**: Scans for `ICommand`, `IQuery<T>` implementations
2. **Generates HTTP Clients**: Creates typed HTTP clients per namespace
3. **Provides Fluent API**: `.ExecuteAsync()` methods on commands/queries
4. **Handles Results**: Integrated with custom Result<T> pattern

```csharp
// Generated code example
public async Task<Result<TResult>> ExecuteAsync(CancellationToken cancellationToken = default)
{
    ApplicationHttpClient client = Config.ServiceResolver.GetRequiredService<ApplicationHttpClient>();
    return await client.QueryAsync(this, cancellationToken);
}
```

#### Benefits Over MediatR
- **Zero Runtime Overhead**: All code generated at compile-time
- **Type Safety**: Full IntelliSense and compile-time checking
- **HTTP Integration**: Direct HTTP client generation
- **Result Pattern**: Unified error handling without exceptions

### Result Pattern Implementation (`src/ApiSdk/Common/Results/Result.cs`)
Comprehensive error handling with:
- Success/Failure states
- Validation error aggregation
- Security exception handling
- HTTP response integration

---

## Database: PostgreSQL + pgvector Architecture

### Advanced PostgreSQL Features

#### Extensions Utilized (`src/API/Infrastructure/ShadowrunContext.cs:13-15`)
```csharp
modelBuilder.HasPostgresExtension("vector");      // Vector similarity search
modelBuilder.HasPostgresExtension("pg_trgm");     // Trigram fuzzy search  
modelBuilder.HasPostgresExtension("unaccent");    // Accent-insensitive search
```

#### Vector Search Implementation (`RuleContentConfiguration.cs:40-42`)
```csharp
b.Property(x => x.Embedding)
 .HasColumnName("embedding")
 .HasColumnType("vector(768)");  // 768-dimensional embeddings
```

### Entity Framework Core Usage

#### Advanced EF Features
- **Snake Case Naming**: `UseSnakeCaseNamingConvention()`
- **Computed Columns**: MD5 hash generation in database
- **GIN Indexes**: Trigram search for fuzzy text matching
- **Vector Indexes**: Optimized similarity search

#### Domain Entities
**RuleContent Entity** (`src/API/Infrastructure/Entities/Import/RuleContent.cs`):
- Hierarchical content with parent/child relationships
- Semantic embeddings with versioning
- Computed hash columns for deduplication
- Comprehensive indexing strategy

**Sourcebook Entity**: Simple aggregate root for PDF imports

### Migration Strategy
- Entity Framework migrations in `src/API/Infrastructure/Migrations/`
- Database-first schema evolution
- Idempotent import pipeline design

---

## Import Pipeline Architecture

### Pipeline Overview
The import system implements a sophisticated builder pattern with clear separation of concerns:

**Parser → Chunker → Classifier → Embedder/Indexer → Structured Persister**

### Component Architecture

#### Director Pattern (`src/API/Importing/Builder/ImportDirector.cs`)
Orchestrates the import pipeline with progress reporting:
```csharp
public async Task<ImportOutcome> RunAsync(ImportWorkItem item, IImportBuilder builder, 
    Func<ImportProgress, Task> report, CancellationToken cancellationToken)
{
    await report(new(ImportStep.Parse, 5, "Parsing"));
    // ... pipeline execution
}
```

#### Background Processing (`src/API/Importing/Hosted/ImportAgent.cs`)
- **Hosted Service**: Background processing of import jobs
- **Channel-Based Queue**: Bounded channels for work distribution
- **Scoped Dependencies**: Proper lifetime management
- **Progress Tracking**: Real-time job status updates

#### Builder Pattern Implementation
Multiple specialized builders:
- `MarkdownImportBuilder`: PDF to structured content
- Factory pattern for builder selection
- Fluent API for pipeline composition

### Advanced Features
- **Structured Extraction**: Spells, weapons, gear from raw text
- **Embedding Generation**: Ollama integration for local embeddings  
- **Idempotent Processing**: Hash-based deduplication
- **Error Recovery**: Granular step-level error handling

---

## AI Integration: Semantic Kernel

### Current Implementation
- **Ollama Connector**: Local embedding generation
- **Plugin Architecture**: Structured for future AI features
- **Kernel Configuration**: Keyed services for different AI contexts

### Planned Integrations
Based on documentation analysis:
- GM assistance plugins
- Character generation helpers
- Rule lookup and interpretation
- Campaign management AI tools

---

## Scaling Recommendations for Event-Driven Architecture

### Current State Assessment
The architecture is well-positioned for EDA migration:

**Strengths:**
- Domain boundaries clearly defined
- Message-based import pipeline
- Background processing infrastructure
- Result-oriented error handling

**Areas for Enhancement:**

### 1. Event Sourcing Migration Path

#### Phase 1: Domain Events
```csharp
// Add to existing entities
public abstract class AggregateRoot
{
    private readonly List<IDomainEvent> _events = new();
    
    protected void RaiseEvent(IDomainEvent domainEvent)
    {
        _events.Add(domainEvent);
    }
}
```

#### Phase 2: Event Store
- Implement EventStore or Marten for event persistence
- Maintain read models in PostgreSQL
- Use pgvector for semantic search on events

### 2. Message Bus Integration

#### Recommended Technologies
- **Azure Service Bus**: For cloud deployments
- **RabbitMQ**: For on-premises/hybrid scenarios
- **MassTransit**: As messaging abstraction layer

#### Integration Points
```csharp
// Extend existing import pipeline
public class ImportCompletedEvent : IDomainEvent
{
    public Guid JobId { get; init; }
    public string SourcebookCode { get; init; }
    public int ContentCount { get; init; }
    public DateTimeOffset CompletedAt { get; init; }
}
```

### 3. CQRS Enhancement

#### Read Model Optimization
- Separate read/write databases
- Materialized views for complex queries
- Event-driven projection updates

#### Query Enhancement
```csharp
// Add to existing source generator
public interface IProjection<TEvent> where TEvent : IDomainEvent
{
    Task ProjectAsync(TEvent @event, CancellationToken cancellationToken);
}
```

### 4. Distributed Caching Strategy

#### Implementation Recommendations
- **Redis**: For session state and frequently accessed data
- **Memory Caching**: For embeddings and search results
- **CDN Integration**: For static UI assets

### 5. Observability Enhancement

#### Telemetry Integration
```csharp
// Extend existing ValueStopwatch usage
public static class TelemetryExtensions
{
    public static IDisposable BeginOperation(this ILogger logger, string operationName)
    {
        return new OperationScope(logger, operationName);
    }
}
```

#### Recommended Stack
- **OpenTelemetry**: Distributed tracing
- **Serilog**: Structured logging
- **Application Insights**: Cloud monitoring

---

## Performance Characteristics

### Current Optimizations
- **Incremental Source Generation**: Compile-time performance
- **Bounded Channels**: Memory-efficient queuing
- **Vector Indexing**: Sub-second semantic search
- **Computed Columns**: Database-level optimizations

### Scaling Bottlenecks
1. **Import Pipeline**: Single-threaded processing
2. **Embedding Generation**: Local LLM limitations
3. **Database Connections**: Connection pooling needs
4. **UI State**: Client-side memory management

### Recommended Improvements
1. **Parallel Import Processing**: Multi-threaded pipeline execution
2. **Distributed Embeddings**: Azure OpenAI or cloud-based models
3. **Connection Pooling**: Advanced EF Core configuration
4. **Client State Management**: Fluxor or similar state container

---

## Security Considerations

### Current Implementation
- **Input Validation**: Custom validation pipeline
- **SQL Injection Prevention**: Parameterized queries via EF Core
- **XSS Protection**: Blazor built-in sanitization

### Enhancement Recommendations
1. **Authentication**: Identity integration
2. **Authorization**: Role-based access control
3. **API Security**: Rate limiting and throttling
4. **Data Encryption**: At-rest and in-transit protection

---

## Development Experience

### Strengths
- **Source Generation**: Eliminates boilerplate
- **Type Safety**: Full compile-time checking
- **Rich Documentation**: Comprehensive project docs
- **Modern Tooling**: Latest .NET 9 features

### Areas for Improvement
1. **Testing Strategy**: No test projects currently exist
2. **CI/CD Pipeline**: Build/deployment automation
3. **Local Development**: Docker Compose for dependencies
4. **Code Analysis**: Static analysis integration

---

## Conclusion

The ShadowrunGM project demonstrates exceptional architectural maturity for its current stage. The custom CQRS implementation is particularly noteworthy, providing MediatR-like benefits without the runtime overhead. The PostgreSQL + pgvector integration shows sophisticated understanding of modern database capabilities.

**Key Recommendations:**
1. **Immediate**: Add comprehensive test coverage
2. **Short-term**: Implement basic event sourcing for audit trails
3. **Medium-term**: Introduce message bus for inter-service communication
4. **Long-term**: Full EDA migration with distributed caching

The foundation is exceptionally solid for scaling to enterprise-level event-driven architecture while maintaining the current high code quality standards.